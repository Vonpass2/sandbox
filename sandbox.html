<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Sand Sandbox</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from appearing */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .control-button.active {
            background-color: #4f46e5;
            color: white;
            box-shadow: 0 0 0 2px #a5b4fc;
        }
        /* Custom styles for range slider */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            width: 150px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #4a5568;
            height: 0.5rem;
            border-radius: 0.5rem;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -4px;
            background-color: #a5b4fc;
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen w-screen">

    <!-- Controls -->
    <div id="controls" class="w-full bg-gray-800 p-2 flex flex-wrap justify-center items-center gap-2 shadow-lg z-10">
        <span class="font-bold mr-2">Elements:</span>
        <button class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="0">Eraser</button>
        <button id="sand-btn" class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="1">Sand</button>
        <button id="water-btn" class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="2">Water</button>
        <button id="dirt-btn" class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="3">Dirt</button>
        <button id="stone-btn" class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="4">Stone</button>
        <button id="sprout-btn" class="control-button px-3 py-1.5 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors duration-200" data-type="5">Sprout</button>
        <div class="w-px h-6 bg-gray-600 mx-2"></div>
         <label for="brush-size" class="mr-2">Brush Size:</label>
        <input type="range" id="brush-size" min="1" max="20" value="5" class="w-32">
        <span id="brush-size-label" class="ml-2 w-6 text-center">5</span>
        <div class="w-px h-6 bg-gray-600 mx-2"></div>
        <button id="clear-btn" class="px-3 py-1.5 bg-red-600 hover:bg-red-500 rounded-md transition-colors duration-200">Clear All</button>
    </div>

    <!-- Canvas Container -->
    <div class="flex-grow w-full h-full">
        <canvas id="gl-canvas"></canvas>
    </div>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_position * 0.5 + 0.5;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D u_grid;
        varying vec2 v_texCoord;

        // Particle Colors
        const vec3 EMPTY_COLOR = vec3(0.1, 0.1, 0.15);
        const vec3 SAND_COLOR = vec3(0.96, 0.83, 0.55);
        const vec3 WATER_COLOR = vec3(0.2, 0.5, 1.0);
        const vec3 DIRT_COLOR = vec3(0.5, 0.3, 0.1);
        const vec3 STONE_COLOR = vec3(0.5, 0.5, 0.5);
        const vec3 SPROUT_COLOR = vec3(0.3, 0.8, 0.2);
        const vec3 PLANT_COLOR = vec3(0.1, 0.5, 0.1);


        void main() {
            vec4 pixel = texture2D(u_grid, v_texCoord);
            float type = pixel.r * 255.0;

            vec3 color = EMPTY_COLOR;
            if (type == 1.0) {
                color = SAND_COLOR;
            } else if (type == 2.0) {
                color = WATER_COLOR;
            } else if (type == 3.0) {
                color = DIRT_COLOR;
            } else if (type == 4.0) {
                color = STONE_COLOR;
            } else if (type == 5.0) {
                color = SPROUT_COLOR;
            } else if (type == 6.0) {
                color = PLANT_COLOR;
            }

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script type="module">
        // --- Main Application ---
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });

        // Particle type constants
        const EMPTY = 0;
        const SAND = 1;
        const WATER = 2;
        const DIRT = 3;
        const STONE = 4;
        const SPROUT = 5;
        const PLANT = 6;

        let gridWidth, gridHeight;
        let grid;
        let activeBrush = SAND;
        let isMouseDown = false;
        let brushSize = 5;

        // --- WebGL Setup ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Error linking program:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const gridUniformLocation = gl.getUniformLocation(program, "u_grid");

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const gridTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, gridTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        // --- Simulation Logic ---
        function initGrid() {
            // Scale grid resolution down for performance
            const resolutionScale = 0.25; 
            gridWidth = Math.floor(canvas.clientWidth * resolutionScale);
            gridHeight = Math.floor(canvas.clientHeight * resolutionScale);
            canvas.width = gridWidth;
            canvas.height = gridHeight;
            gl.viewport(0, 0, gridWidth, gridHeight);
            
            grid = new Uint8Array(gridWidth * gridHeight);
            grid.fill(EMPTY);
        }

        function getCell(x, y) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) {
                return STONE; // Treat out of bounds as stone
            }
            return grid[y * gridWidth + x];
        }

        function setCell(x, y, value) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) {
                return;
            }
            grid[y * gridWidth + x] = value;
        }

        function updateSimulation() {
            for (let y = gridHeight - 1; y >= 0; y--) {
                const scanDirection = Math.random() > 0.5 ? 1 : -1;
                for (let i = 0; i < gridWidth; i++) {
                    const x = scanDirection === 1 ? i : (gridWidth - 1 - i);
                    const type = getCell(x, y);

                    // Skip empty cells and static cells
                    if (type === EMPTY || type === STONE || type === PLANT) continue;
                    
                    // --- Particle Behavior ---
                    if (type === SAND || type === DIRT) {
                        const below = getCell(x, y + 1);
                        if (below === EMPTY || below === WATER) {
                            setCell(x, y, below);
                            setCell(x, y + 1, type);
                        } else {
                            const dir = Math.random() > 0.5 ? 1 : -1;
                            const belowSide = getCell(x + dir, y + 1);
                            if (belowSide === EMPTY || belowSide === WATER) {
                                setCell(x, y, belowSide);
                                setCell(x + dir, y + 1, type);
                            } else {
                                const belowOtherSide = getCell(x - dir, y + 1);
                                if (belowOtherSide === EMPTY || belowOtherSide === WATER) {
                                    setCell(x, y, belowOtherSide);
                                    setCell(x - dir, y + 1, type);
                                }
                            }
                        }
                    } else if (type === WATER) {
                        const below = getCell(x, y + 1);
                        if (below === EMPTY) {
                            setCell(x, y, EMPTY);
                            setCell(x, y + 1, WATER);
                        } else {
                             const dir = Math.random() > 0.5 ? 1 : -1;
                             const side = getCell(x + dir, y);
                             if(side === EMPTY) {
                                setCell(x, y, EMPTY);
                                setCell(x + dir, y, WATER);
                             } else {
                                const otherSide = getCell(x - dir, y);
                                if(otherSide === EMPTY) {
                                    setCell(x, y, EMPTY);
                                    setCell(x - dir, y, WATER);
                                }
                             }
                        }
                    } else if (type === SPROUT) {
                        const below = getCell(x, y + 1);
                        if(below === DIRT) {
                            if(getCell(x+1, y) === WATER || getCell(x-1, y) === WATER || getCell(x, y-1) === WATER) {
                                if (Math.random() < 0.01) { 
                                    setCell(x, y, PLANT);
                                    for(let h=1; h<5 && Math.random() > 0.3; h++) {
                                        if(getCell(x, y-h) === EMPTY) setCell(x, y-h, PLANT);
                                    }
                                }
                            }
                        } else { 
                           setCell(x, y, EMPTY);
                        }
                    }
                }
            }
        }

        // --- Rendering Loop ---
        function draw() {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.bindTexture(gl.TEXTURE_2D, gridTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, gridWidth, gridHeight, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, grid);

            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform1i(gridUniformLocation, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function gameLoop() {
            updateSimulation();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- User Interaction ---
        function paintOnCanvas(e) {
            if (!isMouseDown) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / rect.width * gridWidth);
            const y = Math.floor((e.clientY - rect.top) / rect.height * gridHeight);

            for (let dx = -brushSize; dx <= brushSize; dx++) {
                for (let dy = -brushSize; dy <= brushSize; dy++) {
                    if (dx * dx + dy * dy < brushSize * brushSize) {
                        const cellX = x + dx;
                        const cellY = y + dy;
                        // Allow painting over anything except stone, unless erasing.
                        if (getCell(cellX, cellY) !== STONE || activeBrush === EMPTY) {
                           setCell(cellX, cellY, activeBrush);
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            paintOnCanvas(e);
        });
        canvas.addEventListener('mouseup', () => { isMouseDown = false; });
        canvas.addEventListener('mouseleave', () => { isMouseDown = false; });
        canvas.addEventListener('mousemove', paintOnCanvas);
        
        canvas.addEventListener('touchstart', (e) => {
            isMouseDown = true;
            paintOnCanvas(e.touches[0]);
        }, { passive: true });
        canvas.addEventListener('touchend', () => { isMouseDown = false; });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            paintOnCanvas(e.touches[0]);
        }, { passive: false });

        // --- Control Setup ---
        const controlButtons = document.querySelectorAll('.control-button');
        function setActiveButton(button) {
            controlButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            activeBrush = parseInt(button.dataset.type, 10);
        }
        
        controlButtons.forEach(button => {
            button.addEventListener('click', () => setActiveButton(button));
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            grid.fill(EMPTY);
        });

        const brushSizeSlider = document.getElementById('brush-size');
        const brushSizeLabel = document.getElementById('brush-size-label');
        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value, 10);
            brushSizeLabel.textContent = brushSize;
        });

        // --- Initialization ---
        window.addEventListener('resize', () => {
            initGrid();
        });

        // Set initial state
        setActiveButton(document.getElementById('sand-btn'));
        brushSize = parseInt(brushSizeSlider.value, 10);
        brushSizeLabel.textContent = brushSize;
        initGrid();
        gameLoop();

    </script>
</body>
</html>
